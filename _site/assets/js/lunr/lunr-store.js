var store = [{
        "title": "산업기능요원 편입",
        "excerpt":"산업기능요원으로 편입했습니다.   복무기간은 2019/11/14 ~ 2022/9/13 입니다.   Countdown 에서 남은 기간을 확인할 수 있습니다.  ","categories": ["life","work"],
        "tags": [],
        "url": "http://localhost:5000/life/military/2019-11-14-military/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "Welcome to Jekyll!",
        "excerpt":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.   Jekyll requires blog post files to be named according to the following format:   YEAR-MONTH-DAY-title.MARKUP   Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.   Jekyll also offers powerful support for code snippets:   def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.  Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.   ","categories": ["jekyll","update"],
        "tags": [],
        "url": "http://localhost:5000/2019-12-06-welcome-to-jekyll/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "수포자 양성",
        "excerpt":"자료를 만들다가 나쁜 생각이 들어서 (…) 중1 학생에게 다음과 같은 문제를 선물하기로 했다.   군론      군(group)에 대한 문제이다. 현재 교육과정에서는 이항연산, 항등원, 역원의 내용이 전부 빠져있음에도 출제했다…   (1)번 에서는 더한 후 나머지를 취하는 연산  을 주고 집합  가 군이 됨을 보여야 한다.   (2)번은 cyclic group 에 관한 내용이다.  만을 이용해서  를 생성할 수 있음을 보여야 한다.   해석학      전에  가 무리수인 것에 대해서 얘기한 적이 있었는데, 내가  의 존재성에 대해 고민해 보라고 한 적이 있다. 물론 실수의 완비성이 필요하긴 한데  가 대충 존재한다고 하고…   선형대수학     내적공간(Inner Product Space)에 관한 문제이다. (A), (B), (D) 는 -공간에서 (C) 로 정의된 dot product 가 만족해야 할 조건들이다. (D) 를 이용해 코시-슈바르츠 부등식을 증명하는 것이 핵심이다.     이런 문제를 갖다주면 흥미롭게 풀긴 하지만,   혹시나 나 때문에 수학 포기하지 않길 바란다 …  ","categories": ["math","teach"],
        "tags": [],
        "url": "http://localhost:5000/math/teach/2019-12-06-devil/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "github.io 사이트 설정",
        "excerpt":"사이트를 처음으로 설정하려는데 뭔가 어렵다.   그리고 뭔가 문제들이 몇 가지 보이는데 해결 방법을 몰라서 7시간 동안 삽질만 했다.   현재 해결해야할 문제들      Category 별로 포스트를 보여주지만, 포스트의 개수가 많아질 경우 스압 발생.   상단 메뉴 선택시 해당 토픽의 최근 포스트를 보여줄 때 포스트 개수 제한 없이 모두 보여주어 스압 발생. (paginator 적용 안되어 있음)   이 페이지를 검색하려고 검색에서 사이트 로 검색했는데 결과가 없음.   collection 을 어떻게 사용하는지 잘 모르겠다.            collection 을 사용해서 (Math/CSE/Life) 로 대분류를 나눠보려 했는데, 나누면 메인 화면의 최근 포스트에 다른 대분류가 잡히지 않음.           모바일에서 수식이 지나치게 긴 경우 수식만 튀어나오는 문제 (overflow-x property 로 해결)   Preview Images 설정   Minimal Mistakes Documentation 은 잘 되어있는 것 같은데, 그냥 내가 theme 을 잘못 고른건가 싶다.   지원되는 기능   일단 마크다운이기 때문에 기본적으로 될 것들은 다 되고… 그냥 심심하니 몇개 적어본다.           Syntax Highlighting        #include &lt;cstdio&gt;  using namespace std;   int main() {      printf(\"Hello, github.io!\");  }            print(\"Hello, github.io!\");            public class Main {      public static void main(String[] args) {          System.out.println(\"Hello, github.io!\");      }  }                수식 입력             깔끔해서 마음이 편안해진다.   정리하자면 전체적으로 괜찮은 것 같긴 한데, 스압이 가장 걱정된다. 느려지는 건 정말 원하지 않는다. (+ 모바일 데이터 폭탄 무제한 쓰세요)   스압만 해결하면 적당히 쓸만한 사이트가 되지 않을까 싶다. 스압을 해결하려면 결국엔 이 테마에서 정의된 layout 들을 분석해야 할 것 같은데 Jekyll 로 되어있으니 Documentation 도 읽고 등등… 삽질 좀 더 해야 하나보다.   더 편하게 코딩하자고 하는 삽질인데 그 과정이 무척 고통스러운 건 CSE 특징인 것 같다 …   남은 문제들은 미래의 나에게 맡긴다.  ","categories": ["cse","web"],
        "tags": ["github.io"],
        "url": "http://localhost:5000/cse/web/2019-12-07-site-config/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "자유종(이해조)",
        "excerpt":"자유종   제목: 자유종  작가: 이해조  갈래: 신소설, 토론 소설, 정치 소설  성격: 계몽적, 현실 비판적  시점: 전지적 작가 시점  시간적 배경: 1908년 음력 1월, 이매경 부인의 생일 저녁부터 새벽까지  공간적 배경: 이매경 부인의 집  주제: 바람직한 민족과 국가의 방향 제시  (출처: zum 학습백과 - 자유종)   작품 설명   1910년 에서 간행된 신소설로 개화기의 시사토론체 작품들 중 가장 직접적으로 현실 문제를 다룬 정치성이 매우 강한 작품이다. 하룻밤 사이에 전개되는 사건으로 거의 대화로만 일관되어 있고, 내용이 정치적 토론의 연속이므로 토론회 기록문의 느낌을 준다.   내용은 1908년 음력 정월 16일 이매경 부인의 생일에 초대받은 신설헌, 홍국란, 강금운 등 몇몇 부인들이 한 자리에 모여 민족, 국가, 사회, 교육, 학문, 종교 등에 관하여 밤새도록 토론을 하고서 제각기 꿈을 이야기하는 것이다. 이 토론에 직접 참여하는 인물은 위에 언급한 네 명의 부인에 국한되어 있고, 나머지 부인들은 모두 청중이 되어 있다. 작가가 서술한 지문은 처음과 끝의 몇 줄에 국한되었고 그 밖에는 네 부인의 대화의 연속이다.   주제는 여권신장, 교육을 통한 계몽과 개화, 자주독립과 부국번영, 미신과 계급 및 지방색 타파 등으로 봉건 제도에 비판을 가한 정치적 개혁의식이 뚜렷한 작품이다.   (출처: 우리소설탐구1, 임경순 저)   감상   나는 한국인이지만 생각보다 한글을 잘 모르는 것 같다. 한자 공부를 다시 해야겠다는 생각이 든다. 더불어 옛날 문헌이나, 역사적인 인물의 예화를 들어 비유적으로 설명하는 부분이 많았는데, 작품의 이해를 크게 해치지는 않은 것 같다. 대신 교양을 위해 역사도 좀 알아두면 좋지 않을까 하는 생각은 든다.      관공립은 화욕학교라 실상은 없고 문구뿐이요, 각처 사립은 단명학교라 기본이 없어 번차례로 폐지할 뿐 아니라, 무론 아무 학교든지 그 중에 열심한다는 교장이니 찬성장이니 하는 임원더러 묻되, 이 학교에 제갈량과 이순신과 비사맥과 격란사돈 같은 인재를 교육하여 일후의 국가대사를 경륜하려오 하면 열에 한둘도 없고, 또 묻되 이 학교에 인재 성취는 이 다음 일이요, 교육사회에 명예나 취하려오 하면 열에 칠팔이 더 되니 그 성의가 그러하고야 어찌 장구히 유지하겠소? 교원・강사도 한만(閑漫)한 출입을 아니하고 시간을 지키어 왕래한다니 그 열심은 거룩하오. 공익을 위함인지, 명예를 위함인지, 월급을 위함인지, 명예도 아니요, 월급도 아니요, 실로 공익만 위한다 하는 자, 몇이나 되겠소?     무론 공사관립하고 여러 학생들에게 묻되, 학문을 힘써 일후에 사환(仕宦)을 하든지 일신쾌락을 희망하느냐, 국가에 몸을 바치는 정신 얻기를 주의하느냐 하게 되면, 대중소 학교 몇만 명 학도 중에 국가정신이라고 대답하는 자 몇몇이나 되겠소?    옛날에는 열심히 공부 하고 능력을 키워서 기술을 개발해 세상에 기여하자는 생각을 많이 했었다. 그런데 어떻게 된 일인지 살면 살수록 인류에 기여하려는 마음은 사라져갔고, 나 하나 챙기기 위해 더 힘쓰는 것 같다.      To know even one life has breathed easier  Because you have lived.  This is to have succeeded.  - Ralph Waldo Emerson    중학생 때 읽은 책에서 발견한 성공에 관한 문구인데, 아직도 누군가 나에게 성공이란 무엇인가? 라고 물으면 저렇게 대답해준다. 단 한 명이라도, 삶이 편해진다면 그것이 진정한 성공이라는 말이다.   어떻게 하면 진정한 성공을 이뤄낼 수 있을지는… 공부를 더 한 미래의 내가 답을 해줄 것이다.  ","categories": ["life","books"],
        "tags": ["literature"],
        "url": "http://localhost:5000/life/books/2019-12-10-jayujong/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "BOJ 15686 - 치킨 배달",
        "excerpt":"문제 링크   #include &lt;bits/stdc++.h&gt; using namespace std;  typedef pair&lt;int, int&gt; pii;  vector&lt;pii&gt; house, chicken;  int bitCount(int x) {     int ret = 0;     while(x &gt; 0) {         ret += x &amp; 1;         x &gt;&gt;= 1;     }     return ret; }  int d(pii p1, pii p2) {     return abs(p1.first - p2.first) + abs(p1.second - p2.second); }  int calculate(int mark) {     int ret = 0;     for(pii h : house) {         int k = mark, idx = chicken.size() - 1, dist = 0x7fffffff;         while(k &gt; 0 &amp;&amp; idx &gt;= 0) {             if(k &amp; 1) dist = min(dist, d(h, chicken[idx]));             k &gt;&gt;= 1;             idx--;         }         ret += dist;     }     return ret; }  int main() {     ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);     int n, m, x;     cin &gt;&gt; n &gt;&gt; m;     for(int i = 0; i &lt; n; ++i) {         for(int j = 0; j &lt; n; ++j) {             cin &gt;&gt; x;             if(x == 1) house.push_back({i, j});             else if(x == 2) chicken.push_back({i, j});         }     }     int ans = 0x7fffffff;     int limit = 1 &lt;&lt; chicken.size();     for(int i = 1; i &lt; limit; ++i) {         if(bitCount(i) != m) continue;         ans = min(ans, calculate(i));     }     cout &lt;&lt; ans;     return 0; }   다른 건 그렇다 쳐도 이 긴 코드를 한번에 작성하고 아무 수정 없이 맞았다는게 너무 신기했다.   기본적으로 bitmask 를 적절히 사용하여 치킨집이 남아있으면 , 남아있지 않으면  으로 생각하고, 현재 존재하는 치킨집의 개수가  개 일때,  부터  까지 돌면서 이 중 bitCount 의 값이  인 경우에만 치킨거리를 계산했다.   치킨 거리 계산을 편하게 하기 위해서 집의 위치와 치킨집의 위치는 따로 vector&lt;pii&gt; 에 저장했다. house 의 길이의 최댓값은 , chicken 의 길이의 최댓값은  이다.   시간 복잡도를 계산해 보자.   for 문은 최대  회 수행된다. bitCount 는 상수 시간이므로 무시하고,  번만큼 calculate 가 실행된다.  calculate 의 시간 복잡도는  이므로 총  이다.  ","categories": ["cse","algorithm"],
        "tags": ["brute force"],
        "url": "http://localhost:5000/cse/algo/2019-12-31-BOJ-15686/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "github.io 사이트 설정 - 2",
        "excerpt":"새해를 기념하여 글을 좀 더 열심히 작성하자는 생각에 이 사이트를 다시 방문했다.  지난번에 남겨둔 해결해야 할 문제들을 다시 살펴보았고, 해결 할 수 있는 부분은 해결을 시도했다.   검색 결과가 발생하지 않는 문제     이 페이지를 검색하려고 검색에서 사이트 로 검색했는데 결과가 없음.   왠지 모르겠는데 다시 해보니까 아무 문제 없이 된다. 그런데 footer 쪽에 있는 related posts 에 들어있는 텍스트도 (즉, 해당 포스트에는 직접적으로 포함되지 않는 내용) 감지 되어 검색 결과에 같이 등장한다. 이게 뭐지?   상단 메뉴 별 pagination 적용 문제     상단 메뉴 선택시 해당 토픽의 최근 포스트를 보여줄 때 포스트 개수 제한 없이 모두 보여주어 스압 발생. (paginator 적용 안되어 있음)   사용하는 plugin 중 jekyll-paginate 를 더 이상 사용하지 않기로 하고, jekyll-paginate-v2 를 사용하기로 했다.   _config.yml 에 다음과 같은 내용을 추가했다.   plugins:     - jekyll-paginate-v2  pagination:     enabled: true     per_page: 5     # 5개씩 보여주기     limit: 0     sort_field: \"date\"     sort_reverse: true     title: ':title'     # 타이틀 형식   그리고 Gemfile 에는 다음 내용을 추가했다.   group :jekyll_plugins do     gem \"jekyll-paginate-v2\"   당연히 bundle install 명령어를 한 번 입력해 줘야 하고, index.html 을 다음과 같이 변경했다.   --- layout: home author_profile: true pagination:     enabled: true     per_page: 5 ---   {% for post in paginator.posts %}   {% include archive-single.html %} {% endfor %}  {% if paginator.total_pages &gt; 1 %}     &lt;div class=\"pagination\"&gt;         {% if paginator.previous_page %}             &lt;a href=\"{{ paginator.previous_page_path | prepend: site.baseurl | replace: '//', '/' }}\"&gt;&amp;laquo; Prev&lt;/a&gt;         {% else %}             &lt;span&gt;&amp;laquo; Prev&lt;/span&gt;         {% endif %}          {% for page in (1..paginator.total_pages) %}             {% if page == paginator.page %}                 &lt;em&gt;{{ page }}&lt;/em&gt;              {% elsif page == 1 %}                  &lt;a href=\"{{ '/index.html' | prepend: site.baseurl }}\"&gt;{{ page }}&lt;/a&gt;             {% else %}                 &lt;a href=\"{{ site.paginate_path | prepend: '/' | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}\"&gt;{{ page }}&lt;/a&gt;                  {% endif %}         {% endfor %}          {% if paginator.next_page %}             &lt;a href=\"{{ paginator.next_page_path | prepend: site.baseurl | replace: '//', '/' }}\"&gt;Next &amp;raquo;&lt;/a&gt;         {% else %}             &lt;span&gt;Next &amp;raquo;&lt;/span&gt;         {% endif %}     &lt;/div&gt; {% endif %}    일단 당장은 디자인이 좀 구리다 (…)  Bootstrap 이라도 이용해서 다시 고칠 생각을 하고 있다.   위와 같은 방식을 이용해서 category 별로 저 부분을 다 작성해서 넣어주면 pagination 이 잘 될 것이라고 기대하고 있다.   또 다른 문제를 하나 발견했는데…   Category 가 많아지면 url 이 길어지는 문제  인지하지 못하고 있었는데, category 를 막 집어넣었더니 카테고리들이 / 로 분리되어 전부 url 에 포함되는 것을 확인할 수 있었다. 일단은 임시 방편으로, permalink 를 :path 로만 해두었다.   permalink: /:path/   원하는 것은, /대분류/:title/ 인데, collection 을 사용하면 될 것 같지만, 아직도 collection 은 잘 모르겠다.   아니면 태그를 잘 활용하는 것도 방법이 되지 않을까 고민하고 있다.   TODO      상단의 Category 탭에서는 paginator 를 어떻게 적용해야 할지 전혀 모르겠다. 차라리 tag 를 도입해서 tag 가 같은 문서 끼리만 볼 수 있도록 구현을 하는 것이 방법일 것 같다.   _includes, _layouts 에 뭐가 굉장히 많다. liquid syntax 를 익히고, template 들을 분석해서 사이트를 보다 더 다채롭게 사용할 수 있으면 좋겠다.   추가 내용   변경 사항들을 repo 에 모두 push 했는데, pagination 이 작동하지 않는다. 전체 recent post, CSE 카테고리 recent post 가 전부 보이지 않는다.   일단 의도대로 페이지가 동작하지 않는 이유는 unsupported plugin 을 사용했기 때문이다. Supported plugin 들의 목록은 여기 에서 확인할 수 있었다. jekyll-paginate-v2 는 목록에 없다. 그리고 Github Pages Documentation 을 확인해 보니      GitHub Pages cannot build sites using unsupported plugins. If you want to use unsupported plugins, generate your site locally and then push your site’s static files to GitHub.    라고 한다. 이제 여기 적혀있는 대로 하면 되겠지?   태그별 정리   몇몇 포스트에 태그를 추가하여 /tags/ 로 들어가면 태그 별로 정리되어 있는 글 목록을 볼 수는 있다.   --- title: \"Posts by Tag\" permalink: /tags/ layout: tags author_profile: true ---   하지만 마찬가지로 아직도 글의 개수가 많아질 경우에는 pagination 이 안된다는 문제가 남아있다. 이걸 정말 해결하고 싶다면, 태그별로 페이지를 만들어 주면 되긴 하는데, 새로운 태그가 생길 경우에 그 태그에 해당하는 포스트만 모아둔 페이지를 매번 만들어 줘야 한다는 불편함이 존재하게 된다. 아니면 이대로 두는 것도 방법이다 …  ","categories": ["cse","web"],
        "tags": ["github.io"],
        "url": "http://localhost:5000/cse/web/2020-01-02-site-config2/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "BOJ 3055 - 탈출",
        "excerpt":"문제 링크   #include &lt;bits/stdc++.h&gt; using namespace std;  typedef pair&lt;int, int&gt; pii;  int r, c, ans, dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; string mp[55]; bool visited[55][55], found = false; vector&lt;pii&gt; water; vector&lt;pii&gt; loc;  bool check(int x, int y) {     return 0 &lt;= x &amp;&amp; x &lt; r &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; c; }  void bfs() {     queue&lt;pii&gt; q;     for(pii v : water) {         visited[v.first][v.second] = true;         q.push(v);     }     water.clear();     while(!q.empty()) {         pii curr = q.front();         q.pop();         int x = curr.first, y = curr.second;         for(int i = 0; i &lt; 4; ++i) {             int nx = x + dx[i], ny = y + dy[i];             if(!check(nx, ny) || visited[nx][ny]) continue;             if(mp[nx][ny] == '.') {                 mp[nx][ny] = '*';                 water.push_back({nx, ny});             }         }     }      ans++;      queue&lt;pii&gt; qu;     for(pii v : loc) {         visited[v.first][v.second] = true;         qu.push(v);     }     loc.clear();     while(!qu.empty()) {         pii curr = qu.front();         qu.pop();         int x = curr.first, y = curr.second;         for(int i = 0; i &lt; 4; ++i) {             int nx = x + dx[i], ny = y + dy[i];             if(!check(nx, ny) || visited[nx][ny]) continue;             if(mp[nx][ny] == '.') {                 mp[nx][ny] = 'S';                 loc.push_back({nx, ny});             } else if(mp[nx][ny] == 'D') {                 found = true;                 return;             }         }     } }  int main() {     cin &gt;&gt; r &gt;&gt; c;     for(int i = 0; i &lt; r; ++i) cin &gt;&gt; mp[i];     for(int i = 0; i &lt; r; ++i) {         for(int j = 0; j &lt; c; ++j) {             if(mp[i][j] == 'S') {                 loc.push_back({i, j});             } else if(mp[i][j] == '*') {                 water.push_back({i, j});             } else if(mp[i][j] == 'X') {                 visited[i][j] = true;             }         }     }         while(!found &amp;&amp; (loc.size() || water.size())) bfs();     if(!found) cout &lt;&lt; \"KAKTUS\";     else cout &lt;&lt; ans;     return 0; }  ","categories": ["cse","algorithm"],
        "tags": ["BFS"],
        "url": "http://localhost:5000/cse/algo/2020-01-06-BOJ-3055/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "BOJ 15683 - 감시",
        "excerpt":"문제 링크   구현이 복잡해서 좀 골치아팠다. 문제 자체가 엄청 복잡하지는 않다. CCTV 들의 위치를 기억해 뒀다가, CCTV 가 감시할 수 있는 모든 방향 조합에 따라 감시가 되는 구역을 조사하고, 감시 되지 않는 곳을 세어주면 된다.   아래 내용이 처음으로 정답을 받은 코드이다.   #include &lt;bits/stdc++.h&gt; using namespace std;  typedef pair&lt;int, int&gt; pii;  int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0}; int one[1] = {0}, two[2] = {0, 2}, three[2] = {0, 1}, four[3] = {0, 1, 2}, five[4] = {0, 1, 2, 3}; vector&lt;pii&gt; cctv; vector&lt;vector&lt;int&gt;&gt; mp; int n, m;  void mark(vector&lt;vector&lt;int&gt;&gt;&amp; mp, int x, int y, int state);  void nextState(vector&lt;int&gt;&amp; s) {     int len = cctv.size() - 1;     s[len]++;     for(; len &gt;= 0; --len) {         if(s[len] == 4 &amp;&amp; len != 0) {             s[len] = 0;             s[len - 1]++;             if(s[len - 1] != 4) break;         }     }     if(s[0] == 4) s[0] = -1; }  bool checkRange(int x, int y) {     return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m; }  int main() {     ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);     cin &gt;&gt; n &gt;&gt; m;     mp.resize(n);     for(int i = 0; i &lt; n; ++i) {         mp[i].resize(m);         for(int j = 0; j &lt; m; ++j) {             cin &gt;&gt; mp[i][j];             if(mp[i][j] != 0 &amp;&amp; mp[i][j] != 6)                 cctv.push_back({i, j});         }     }     int len = cctv.size(), ans = 0x7fffffff;     if(len == 0) {         int cnt = 0;         for(int i = 0; i &lt; n; ++i) {             for(int j = 0; j &lt; m; ++j) {                 if(mp[i][j] == 0) cnt++;             }         }         cout &lt;&lt; cnt;         return 0;     }     vector&lt;int&gt; state(len, 0);     while(state[0] != -1) {         vector&lt;vector&lt;int&gt;&gt; curr(n);         copy(mp.begin(), mp.end(), curr.begin());         for(int idx = 0; idx &lt; cctv.size(); ++idx) {             pii tv = cctv[idx];             int x = tv.first, y = tv.second;             int st = state[idx];             mark(curr, x, y, st);         }         int cnt = 0;         for(int i = 0; i &lt; n; ++i) {             for(int j = 0; j &lt; m; ++j) {                 if(curr[i][j] == 0) cnt++;             }         }         ans = min(ans, cnt);         nextState(state);     }     cout &lt;&lt; ans;     return 0; }  void mark(vector&lt;vector&lt;int&gt;&gt;&amp; mp, int x, int y, int state) {     switch(mp[x][y]) {         case 1:             for(int d : one) {                 int nx = x + dx[(d + state) % 4], ny = y + dy[(d + state) % 4];                 while(checkRange(nx, ny) &amp;&amp; mp[nx][ny] != 6) {                     if(mp[nx][ny] &lt;= 0) mp[nx][ny] = -1;                     nx += dx[(d + state) % 4];                     ny += dy[(d + state) % 4];                 }             }                             break;         case 2:             for(int d : two) {                 int nx = x + dx[(d + state) % 4], ny = y + dy[(d + state) % 4];                 while(checkRange(nx, ny) &amp;&amp; mp[nx][ny] != 6) {                     if(mp[nx][ny] &lt;= 0) mp[nx][ny] = -1;                     nx += dx[(d + state) % 4];                     ny += dy[(d + state) % 4];                 }             }                   break;         case 3:             for(int d : three) {                 int nx = x + dx[(d + state) % 4], ny = y + dy[(d + state) % 4];                 while(checkRange(nx, ny) &amp;&amp; mp[nx][ny] != 6) {                     if(mp[nx][ny] &lt;= 0) mp[nx][ny] = -1;                     nx += dx[(d + state) % 4];                     ny += dy[(d + state) % 4];                 }             }                break;         case 4:             for(int d : four) {                 int nx = x + dx[(d + state) % 4], ny = y + dy[(d + state) % 4];                 while(checkRange(nx, ny) &amp;&amp; mp[nx][ny] != 6) {                     if(mp[nx][ny] &lt;= 0) mp[nx][ny] = -1;                     nx += dx[(d + state) % 4];                     ny += dy[(d + state) % 4];                 }             }                break;         case 5:             for(int d : five) {                 int nx = x + dx[(d + state) % 4], ny = y + dy[(d + state) % 4];                 while(checkRange(nx, ny) &amp;&amp; mp[nx][ny] != 6) {                     if(mp[nx][ny] &lt;= 0) mp[nx][ny] = -1;                     nx += dx[(d + state) % 4];                     ny += dy[(d + state) % 4];                 }             }                break;     } }   4019B 라니 말도 안된다…   우선 문제의 입력을 받으며 CCTV 가 들어오면 그 좌표를 vector&lt;pii&gt; cctv 에 저장해 둔다. 이제 cctv.size() 만큼의 vector&lt;int&gt; state 를 선언하여 CCTV 들의 감시 방향을 관리한다. i 번째 CCTV 의 감시 방향은 state[i] 에  의 값으로 저장되어 있다.  인 경우에는 문제 설명에 있는 기본 상태이고,  씩 증가할 때마다  씩 반시계 방향으로 돌아간 상태이다.   이러한 state 들을 계산해주기 위해 nextState() 를 구현했다. 진법 정수를 구현한 셈이다. 맨 앞 자리 숫자가 가 되면 state 들을 모두 조사한 것으로 판단하고 첫 자리를  로 바꿔주어 while 문에서 판단할 수 있도록 했다.   while 문은 state 를 모두 조사할 때 까지 실행된다. while 내부는 간단하다. 우선 지도를 복사하고, 각 CCTV 의 위치와 감시 방향 정보를 이용해 감시되는 구역을 지도에 표시해준다. 이를 mark 함수가 처리해 줄 것이다. 이 과정이 끝나면 감시 되지 않는 구역의 개수만 세어 최솟값을 구해주면 끝난다.   mark 함수 때문에 고민을 참 많이 했다. mark 에서는 현재 지도, CCTV 의 위치, state 를 이용해 지도에 감시되는 곳을 표시할 것이다. 우선 CCTV 의 종류를 판별하고, 지도를 벗어나지 않는 동안 감시된 곳은  로 바꿔주었다. 첫 구현은 대략 이런 모양이었다.   int nx = x + dx[(d + state) % 4], ny = y + dy[(d + state) % 4]; while(checkRange(nx, ny)) {     mp[nx][ny] = -1;     nx += dx[(d + state) % 4];     ny += dy[(d + state) % 4]; }   이렇게 돌려보니 당연히 벽을 뚫고 감시해버렸다. 그래서 while 안에 mp[nx][ny] &lt;= 0 이라는 조건을 추가해서 이미 감시된 구역이나 감시 되지 않은 구역에 대해서만 while 이 실행되도록 했다. (이 과정에서 mp[ny][ny] &lt;= 0 으로 적은 오타를 발견하지 못해 시간이 많이 소요되었다…) 이렇게 했더니 예제는 맞길래, 제출해 봤더니 틀렸다.   나중에 알고보니 CCTV 는 벽을 넘어서는 감시를 못하지만 CCTV 를 넘어서는 감시할 수 있다는 사실을 깨닫고 while 의 조건을 수정했다.   int nx = x + dx[(d + state) % 4], ny = y + dy[(d + state) % 4]; while(checkRange(nx, ny) &amp;&amp; mp[nx][ny] != 6) {     if(mp[nx][ny] &lt;= 0) mp[nx][ny] = -1;     nx += dx[(d + state) % 4];     ny += dy[(d + state) % 4]; }   이렇게 제출하니 런타임 에러를 받았고 (ㅋㅋ) CCTV 가 한 개도 들어오지 않는 경우를 처리하지 않았다는 사실을 알았다. 이 부분을 처리해 주니 맞았습니다를 받았고, 코드는 4019B 였다. 줄이자!   우선 각 CCTV 의 종류에 따라 감시 방향을 5개의 다른 배열에 저장했었는데, 이를 vector&lt;vector&lt;int&gt;&gt; 하나로 합쳤다. 그리고 mark 함수를 호출하기 전에 CCTV 의 종류를 판단하도록 하여 중복되는 코드를 싹 제거했다. 최종 코드는 다음과 같다.    #include &lt;bits/stdc++.h&gt; using namespace std;  typedef pair&lt;int, int&gt; pii;  int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0}; vector&lt;vector&lt;int&gt;&gt; dir = {{0}, {0, 2}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}}; vector&lt;pii&gt; cctv; vector&lt;vector&lt;int&gt;&gt; mp; int n, m;  void mark(vector&lt;vector&lt;int&gt;&gt;&amp; mp, int x, int y, int state) {     int nx = x + dx[state], ny = y + dy[state];     while(checkRange(nx, ny) &amp;&amp; mp[nx][ny] != 6) {         if(mp[nx][ny] &lt;= 0) mp[nx][ny] = -1;         nx += dx[state];         ny += dy[state];     } }  void nextState(vector&lt;int&gt;&amp; s) {     int len = cctv.size() - 1;     s[len]++;     for(; len &gt;= 0; --len) {         if(s[len] == 4 &amp;&amp; len != 0) {             s[len] = 0;             s[len - 1]++;             if(s[len - 1] != 4) break;         }     }     if(s[0] == 4) s[0] = -1; }  bool checkRange(int x, int y) {     return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m; }  int main() {     ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);     cin &gt;&gt; n &gt;&gt; m;     mp.resize(n);     for(int i = 0; i &lt; n; ++i) {         mp[i].resize(m);         for(int j = 0; j &lt; m; ++j) {             cin &gt;&gt; mp[i][j];             if(mp[i][j] != 0 &amp;&amp; mp[i][j] != 6)                 cctv.push_back({i, j});         }     }     int cnt = 0;     for(int i = 0; i &lt; n; ++i) {         for(int j = 0; j &lt; m; ++j) {             if(mp[i][j] == 0) cnt++;         }     }     int len = cctv.size(), ans = cnt;     if(len == 0) {         cout &lt;&lt; ans;         return 0;     }     vector&lt;int&gt; state(len, 0);     while(state[0] != -1) {         vector&lt;vector&lt;int&gt;&gt; curr(n);         copy(mp.begin(), mp.end(), curr.begin());         for(int idx = 0; idx &lt; cctv.size(); ++idx) {             pii tv = cctv[idx];             int x = tv.first, y = tv.second;             int st = state[idx];             for(int d : dir[mp[x][y] - 1])  \t            mark(curr, x, y, (d + st) % 4);         }         int cnt = 0;         for(int i = 0; i &lt; n; ++i) {             for(int j = 0; j &lt; m; ++j) {                 if(curr[i][j] == 0) cnt++;             }         }         ans = min(ans, cnt);         nextState(state);     }     cout &lt;&lt; ans;     return 0; }    여기서 조금 더 최적화를 하고 싶다면,  번 CCTV 에 대해 굳이 state 를 관리하지 않는 방법이 있을 것이다. 현재 구현 상으로는 무조건  번 조사를 하니, 번 CCTV 의 비율이 높은 경우에는 실행 시간이 꽤 줄어들 것이다.   시간 복잡도   CCTV 가  개 인 경우, 모든 state 의 개수는  개 이고, 각 state 마다 한 CCTV 의 감시 구역을 mark 하는 비용은 많아야 지도에서 가로, 세로 각각 한 줄 씩이므로  이다.   따라서 각 state 마다 지도에 mark 하는 총 비용은  이므로, 최종 시간 복잡도는     이 된다.  이므로 시간 내에 잘 작동한다.  ","categories": ["cse","algorithm"],
        "tags": ["brute force"],
        "url": "http://localhost:5000/cse/algo/2020-01-07-BOJ-15683/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"},{
        "title": "하버드 새벽 4시 반",
        "excerpt":"하버드 새벽 4시 반   일단 나는 요즘 새벽 5시 반에 일어난다. 무척 힘들다. 친구들이 어떻게 하냐고 한다. 그런데 책 제목을 보니 기상 시간을 한 시간 당겨야 하는지도 모르겠다 ㅋㅋ.   일상이 무기력해진 사람에게 꼭 추천하고 싶은 책이다. 저자는 각종 하버드 대학 교수의 강의 내용, 일화 등을 인용하여 우리가 더욱 발전하고, 인생에서 성공하기 위해서 우리가 가져야할 태도에 대해서 강조한다. 나는 보통 책을 읽다가 책이 너무 좋으면 컴퓨터를 켜서 인상 깊은 구절들을 전부 다 메모장에 적어 두는 편이다. 아쉽게도 출퇴근 길에 시간을 내서 읽다 보니 컴퓨터가 없어서 그렇게 하지는 못했다. 굳이 이렇게 하지 않더라도, 이 책의 어느 페이지에서나 청춘에게 열정과 자신감을 불어 넣어주고, 동기부여를 확실하게 해주는 내용을 찾을 수 있을 것이다.   사실 이런 책은 목차만 봐도 된다.      우리가 실패하는 유일한 이유는 ‘노력 부족’ 이다.   “난 할 수 있다”의 마법   열정은 우리를 뛰게 한다   행동하고, 또 행동하라   세상에서 가장 리스크 적은 생산, 배움   유연한 사고의 위대한 힘   시간 관리의 달인이야말로 최고의 부자다   철저한 자기관리의 힘   꿈이 없는 청춘은 아프다   주어진 기회를 알아보는 눈   목차만 봐도, 내가 성장하기 위해서 어떤 마음가짐을 가져야 하는지는 충분히 추측이 가능하다. 책을 읽어보지 않아도 대충 목차만 가지고 책을 요약 할 수 있을 것 같다.      꿈이 없는 청춘은 아프다. 그러므로 젊은 때에 우리는 꿈을 우선 찾아야 한다. 단, 그 꿈은 정말 우리가 간절하게 원하는 것이어야 한다. 그렇다면 자연스럽게 열정이 생겨서 우리를 뛰게 할 것이고, 그 열정을 바탕으로 우리는 행동하고 또 행동할 것이다. 꿈을 향해 한 걸음 한 걸음 나아가면서 기회가 주어졌을 때, 그 기회를 놓치지 않을 수 있도록, 끊임없이 배워야 하며, 그 과정 속에서 유연한 사고 능력을 길러야 한다. 이 때, 우리는 실패하지 않도록 충분한 노력을 해야 할 것이며, 지치고 힘들 때는 “난 할수 있다”고 자신감을 충전해야 한다. 이렇게 노력하는 과정 속에서 해이해지지 않도록 철저하게 자기 관리 하는 것 또한 중요하고, 특별히 모두에게 똑같이 주어진 시간은 반드시 효율적으로 사용해야 할 것이다.    (억지로 짜 맞춘 느낌이 있지만 이 정도면 책이 전달하고자 하는 바는 모두 담은 듯 하다)   나에게 특별히 와닿은 부분이 몇 가지 있다.   꿈이 없는 청춘 이라는 단어가 나를 고민하게 만들었다. 컴퓨터공학부에 진학한 이유는 알파고를 보고 인공지능을 공부하고 발전시켜서 삶에 편의를 가져오고 싶었기 때문이었다. 그런데 막상 입학하고 나니 컴퓨터에는 다양한 분야가 존재한다는 것을 알게 되었고, 각 분야 나름대로 흥미롭고 더 깊이 공부하고 싶은 부분들이 있어서, 현재 나는 한 가지 분야를 정하지 못한 채, 여러 분야의 공부를 다양하게 하고 있다. 분야를 정하지 못해 꿈이 갑자기 사라진 것이다.   물론 내가 공부하는 내용은 학부 수준의 기초 지식이니, 학부 수준에서 다양한 분야의 기초 지식을 갖추는 것은 분명 도움이 될 것이다. 하지만 농사를 지을 때 가지치기 라는게 있지 않은가. 선택과 집중을 하지 않으면, 어느 하나도 제대로 이룰 수 없게 된다. 그리고 이렇게 선택과 집중을 하지 않음으로 인해 발생한 실패를 능력 부족, 혹은 노력 부족으로 생각하고 포기하게 된다. 가만히 돌아 보면 내가 그랬다.   학교 공부 외에도 현재 내가 관심있게 공부하는 분야는 크게 수학, 보안, 알고리즘, 웹 프로그래밍, 인공지능 이렇게 5가지이다. 정말 말 그대로 ‘크게’ 5가지이다. 심도 있게 공부하려면, 세부 과목을 각각 공부해야 하며, 그러면 공부해야할 양이 기하급수적으로 늘어나는 것은 당연지사다. 그러니 어느 하나도 제대로 할 수 없는 것이다.   이제 현재 상태에서 나의 문제점은 알았고, 책에서 결단하고 당장 행동하라고 했으므로 나는 빨리 이 문제를 개선하고 실천에 옮겨야 한다. 이 문제를 개선하는 방법은 “이론상” 간단하다. 정말 내 꿈이라고 생각하는 분야만 남기고, 나머지는 가지치기 하는 것이다. 말로만 쉽다. 사실 가지치기 해야한다는 사실은 1년 전에도 난 알고 있었는데, 정하지 못해서 5가지 분야중 단 하나도 놓지 못한 것이다. 난 대체 무엇에 미련이 있는 걸까?   그럼 조금 더 근본적인 문제를 살펴보자. 왜 나는 꿈을 구체화하지 못하고 있을까? 일단 인류에 도움이 되는 과학 기술을 만들고, 삶의 질을 향상시키고 싶다는 막연한 꿈은 있다. 그 구체적인 방법을 모르는 것이다. 그렇다면 그 방법은 어떻게 찾아야 할까?   내가 그동안 너무 내 일에만 집중하지 않았나 돌아보게 된다. 오로지 나만 중요했고, 나는 주변을 돌아보지 않았다. 책에서도, 의외로 아이디어는 일상 속에 숨어 있다고 했는데, 나의 일상은 공부와 게임이니 (공부도 새로운 것을 창조하는 공부가 아니라 이미 있는 지식을 습득하는 공부였기에) 그런 곳에서 아이디어를 찾기란 쉽지 않을 것이다.   이제 내가 가진 에너지를 꿈을 찾기 위해 사용하는 방향으로 집중해야겠다.  ","categories": ["life","books"],
        "tags": ["books"],
        "url": "http://localhost:5000/life/books/2020-01-07-harvard-4-30-am/",
        "teaser":"http://localhost:5000/assets/images/page-icon.png"}]
